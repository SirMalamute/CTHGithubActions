import os, subprocess, tempfile, shutil, logging
from datetime import datetime, timezone
from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel
from github import Github

app = FastAPI(redirect_slashes=False)

LOGS_DIR = os.path.join(os.path.dirname(__file__), "logs")
os.makedirs(LOGS_DIR, exist_ok=True)

class TriggerRequest(BaseModel):
    repo: str
    branch: str
    github_token: str
    run_id: str

@app.post("/agent/trigger")
async def trigger_agent(body: TriggerRequest, background_tasks: BackgroundTasks):
    work_dir = tempfile.mkdtemp(prefix="crow-")
    background_tasks.add_task(run_agent_and_open_pr, body.repo, body.branch, body.github_token, body.run_id, work_dir)
    return {"status": "started"}

def get_logger(run_id: str) -> tuple[logging.Logger, str]:
    timestamp = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M%S")
    log_filename = os.path.join(LOGS_DIR, f"run-{timestamp}-{run_id}.txt")

    logger = logging.getLogger(run_id)
    logger.setLevel(logging.DEBUG)
    logger.propagate = False  # don't double-print to root logger

    # File handler ‚Äî saves to logs/
    fh = logging.FileHandler(log_filename)
    fh.setFormatter(logging.Formatter("%(asctime)s  %(message)s", datefmt="%Y-%m-%d %H:%M:%S"))
    logger.addHandler(fh)

    # Stream handler ‚Äî prints to uvicorn terminal
    sh = logging.StreamHandler()
    sh.setFormatter(logging.Formatter("%(asctime)s  %(message)s", datefmt="%Y-%m-%d %H:%M:%S"))
    logger.addHandler(sh)

    return logger, log_filename

def run_agent_and_open_pr(repo_full_name, branch, github_token, run_id, work_dir):
    logger, log_file = get_logger(run_id)
    logger.info(f"=== Job started ‚Äî repo={repo_full_name} branch={branch} run_id={run_id} ===")

    try:
        repo_url = f"https://x-access-token:{github_token}@github.com/{repo_full_name}.git"
        app_dir = os.path.join(work_dir, "app")

        logger.info("Cloning repo...")
        _run(["git", "clone", "--depth", "1", "--branch", branch, repo_url, app_dir], logger=logger)
        _run(["git", "config", "user.email", "crow-bot@crow.dev"], cwd=app_dir, logger=logger)
        _run(["git", "config", "user.name", "Crow Bot"], cwd=app_dir, logger=logger)
        logger.info("Repo cloned.")

        logger.info("Running agent...")
        agent_script = os.path.join(os.path.dirname(__file__), "agent.py")
        _run(["python3", "-u", agent_script, "--repo-path", app_dir], logger=logger)
        logger.info("Agent finished.")

        pr_md_path = os.path.join(app_dir, "PR.md")
        if os.path.exists(pr_md_path):
            with open(pr_md_path, "r") as f:
                pr_body = f.read()
            os.remove(pr_md_path)
            logger.info("Read and removed PR.md")
        else:
            pr_body = "## Integrated Crow üê¶\n\nAutomatically generated by Crow agent."
            logger.info("No PR.md found, using default description.")

        timestamp = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M%S")
        new_branch = f"crow/integrate-{branch}-{timestamp}"

        logger.info(f"Committing to branch {new_branch}...")
        _run(["git", "checkout", "-b", new_branch], cwd=app_dir, logger=logger)
        _run(["git", "add", "--all"], cwd=app_dir, logger=logger)
        _run(["git", "commit", "-m", f"chore: integrate Crow ({timestamp})"], cwd=app_dir, logger=logger)
        _run(["git", "push", "origin", new_branch], cwd=app_dir, logger=logger)

        logger.info("Opening PR...")
        gh = Github(github_token)
        repo = gh.get_repo(repo_full_name)
        pr = repo.create_pull(
            title="Integrated Crow",
            body=pr_body,
            head=new_branch,
            base=branch,
        )
        logger.info(f"=== PR opened: {pr.html_url} ===")

    except Exception as e:
        logger.error(f"=== Job failed: {e} ===")
        raise

    finally:
        logger.info(f"Log saved to {log_file}")
        shutil.rmtree(work_dir, ignore_errors=True)

def _run(cmd, cwd=None, logger=None):
    process = subprocess.Popen(
        cmd,
        cwd=cwd,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1,
    )
    output_lines = []
    for line in process.stdout:
        line = line.rstrip()
        if line:
            output_lines.append(line)
            if logger:
                logger.info(line)
            else:
                print(line, flush=True)
    process.wait()
    if process.returncode != 0:
        raise RuntimeError(f"{' '.join(cmd)} failed:\n" + "\n".join(output_lines))
    return "\n".join(output_lines)